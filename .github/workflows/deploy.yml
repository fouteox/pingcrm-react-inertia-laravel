name: Build and Deploy

on:
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ${{ vars.SYSTEM_ARCH == 'aarch64' && 'ubuntu-24.04-arm' || 'ubuntu-latest' }}
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v5

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push App image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          target: app
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}-app
          cache-from: type=gha,scope=app
          cache-to: type=gha,mode=max,scope=app

      - name: Build and push SSR image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          target: ssr
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:ssr
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}-ssr
          cache-from: type=gha,scope=ssr
          cache-to: type=gha,mode=max,scope=ssr

  deploy:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    env:
      STACK_NAME: ${{ github.event.repository.name }}
      USE_CF_TUNNEL: ${{ secrets.USE_CLOUDFLARE_TUNNEL }}

    steps:
      - uses: actions/checkout@v5

      - name: Load .env and export variables
        run: |
          echo "${{ secrets.ENV_FILE_BASE64 }}" | base64 -d > .env.production

          # Calculate hash for versioned secret name
          ENV_HASH=$(sha256sum .env.production | cut -c1-8)
          echo "ENV_HASH=$ENV_HASH" >> $GITHUB_ENV

          # Export all variables to GITHUB_ENV for compose substitution AND backup restore
          while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" || "$line" == \#* ]] && continue
            if [[ $line =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
              key="${BASH_REMATCH[1]}"
              value="${BASH_REMATCH[2]}"
              value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//')
              echo "::add-mask::$value"
              echo "$key=$value" >> $GITHUB_ENV
            fi
          done < .env.production

          # Add IMAGE_NAME for compose substitution
          echo "IMAGE_NAME=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" >> $GITHUB_ENV

      - name: Install cloudflared
        if: env.USE_CF_TUNNEL == 'true'
        run: |
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb

      - name: Setup SSH
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          name: id_ed25519
          known_hosts: unnecessary
          config: |
            Host deploy-target
              HostName ${{ secrets.SSH_HOST }}
              User ${{ secrets.SSH_USER }}
              IdentityFile ~/.ssh/id_ed25519
              StrictHostKeyChecking accept-new
              ${{ env.USE_CF_TUNNEL == 'true' && 'ProxyCommand cloudflared access ssh --hostname %h' || format('Port {0}', secrets.SSH_PORT) }}

      - name: Login to registry on remote
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker -H ssh://deploy-target login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Check first deploy & restore backup
        run: |
          # Check if DB volume exists (indicates not first deploy)
          if docker -H ssh://deploy-target volume inspect ${STACK_NAME}_stack-mariadb > /dev/null 2>&1; then
            echo "Existing deployment detected"
            exit 0
          fi

          echo "First deploy detected"

          # Extract MariaDB image from compose file (single source of truth)
          MARIADB_IMAGE=$(docker compose -f compose.prod.yaml config --format json | jq -r '.services.mariadb.image')
          echo "Using MariaDB image: $MARIADB_IMAGE"

          # Skip if no S3 backup configured
          [[ -z "${BACKUP_S3_BUCKET:-}" ]] && exit 0

          # Download latest backup
          LATEST=$(docker -H ssh://deploy-target run --rm \
            -e AWS_ACCESS_KEY_ID="${BACKUP_AWS_ACCESS_KEY_ID}" \
            -e AWS_SECRET_ACCESS_KEY="${BACKUP_AWS_SECRET_ACCESS_KEY}" \
            -e AWS_ENDPOINT_URL="https://${BACKUP_AWS_ENDPOINT}" \
            amazon/aws-cli s3 ls "s3://${BACKUP_S3_BUCKET}/${BACKUP_S3_PATH}/" 2>/dev/null \
            | grep '\.tar\.gz' | sort | tail -1 | awk '{print $4}') || true

          [[ -z "$LATEST" ]] && { echo "No backup found"; exit 0; }

          echo "Restoring from: $LATEST"

          # Download and extract backup
          docker -H ssh://deploy-target run --rm \
            -v ${STACK_NAME}_backup_dumps:/restore \
            -e AWS_ACCESS_KEY_ID="${BACKUP_AWS_ACCESS_KEY_ID}" \
            -e AWS_SECRET_ACCESS_KEY="${BACKUP_AWS_SECRET_ACCESS_KEY}" \
            -e AWS_ENDPOINT_URL="https://${BACKUP_AWS_ENDPOINT}" \
            amazon/aws-cli s3 cp "s3://${BACKUP_S3_BUCKET}/${BACKUP_S3_PATH}/$LATEST" /restore/backup.tar.gz

          docker -H ssh://deploy-target run --rm \
            -v ${STACK_NAME}_backup_dumps:/restore \
            alpine sh -c "tar -xzf /restore/backup.tar.gz -C /restore --strip-components=2 backup/dumps/ && rm /restore/backup.tar.gz"

          # Restore MariaDB
          docker -H ssh://deploy-target run -d --name temp-mariadb \
            -v ${STACK_NAME}_stack-mariadb:/var/lib/mysql \
            -v ${STACK_NAME}_backup_dumps:/dumps \
            -e MARIADB_ALLOW_EMPTY_ROOT_PASSWORD=yes \
            -e MARIADB_DATABASE="${DB_DATABASE}" \
            -e MARIADB_USER="${DB_USERNAME}" \
            -e MARIADB_PASSWORD="${DB_PASSWORD}" \
            "$MARIADB_IMAGE"

          echo "Waiting for MariaDB..."
          until docker -H ssh://deploy-target exec temp-mariadb mariadb-admin ping --silent 2>/dev/null; do sleep 2; done

          docker -H ssh://deploy-target exec temp-mariadb sh -c \
            'mariadb -u"$MARIADB_USER" -p"$MARIADB_PASSWORD" "$MARIADB_DATABASE" < /dumps/mariadb.sql' || true

          docker -H ssh://deploy-target rm -f temp-mariadb

          # Restore Valkey (just copy dump.rdb)
          docker -H ssh://deploy-target run --rm \
            -v ${STACK_NAME}_backup_dumps:/source:ro \
            -v ${STACK_NAME}_stack-valkey:/data \
            alpine cp /source/valkey.rdb /data/dump.rdb 2>/dev/null || true

      - name: Deploy stack
        run: |
          docker -H ssh://deploy-target stack deploy \
            --with-registry-auth \
            --detach=false \
            --prune \
            -c compose.prod.yaml \
            ${STACK_NAME}

      - name: Cleanup old secrets
        run: |
          # Remove old laravel_env secrets (keep only the current one)
          docker -H ssh://deploy-target secret ls --format '{{.Name}}' \
            | grep '^laravel_env_' \
            | grep -v "laravel_env_${ENV_HASH}" \
            | xargs -r docker -H ssh://deploy-target secret rm || true

      - name: Cleanup .env.production
        run: rm -f .env.production
